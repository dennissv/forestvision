# -*- coding: utf-8 -*-
"""
Created on Mon Oct 17 10:35:06 2016

@author: Dennis
"""

from pykalman import KalmanFilter
import pylab as pl
import numpy as np
from vtk_visualizer import *

#File input
camera1, camera2, camera3, ins = [], [], [], []
fname = 'dataCameraLeftAndMid.txt'
f = open(fname, 'r')
first = True
for line in f:
    if not first:
        split1 = map(float, line.split('\t'))
        camera1.append(split1)
    first = False
f.close()
    
fname = 'dataCameraLeftAndRight.txt'
f = open(fname, 'r')
first = True
for line in f:
    if not first:
        split1 = map(float, line.split('\t'))
        camera2.append(split1)
    first = False
f.close()
    
fname = 'dataCameraMidAndRight.txt'
f = open(fname, 'r')
first = True
for line in f:
    if not first:
        split1 = map(float, line.split('\t'))
        camera3.append(split1)
    first = False
f.close()
    
f = open('Runt runt 1.txt', 'r')
c = 0
for line in f:
    if c > 4:    
        split1 = map(float, line.split('\t')[:13])
        ins.append(split1)
    c += 1
f.close()

#Combining into seperate lists
c = 0
cx,cy,cz = [],[],[]
for i in camera1:
    temp = [camera1[c][0],camera2[c][0],camera3[c][0]]
    cx.append(temp)
    temp = [camera1[c][1],camera2[c][1],camera3[c][1]]
    cy.append(temp)
    temp = [camera1[c][2],camera2[c][2],camera3[c][2]]
    cz.append(temp)
    c += 1
    
roll, pitch, yaw, time = [], [], [], []
c = 0
for i in ins:
    time.append(ins[c][3])
    roll.append(ins[c][4])
    pitch.append(ins[c][5])
    yaw.append(ins[c][6])
    c += 1

#Average it into single observations
c = 0
obsx,obsz,obsy,opx1,opy1,opz1,opx2,opy2,opz2,opx3,opy3,opz3 = [],[],[],[],[],[],[],[],[],[],[],[]
for i in cx:
    if c == 0:
        obsx.append((cx[c][0]+cx[c][2])/2)
        obsy.append((cy[c][0]+cy[c][2])/2)
        obsz.append((cz[c][0]+cz[c][2])/2)
        opx1.append(cx[c][0])
        opy1.append(cy[c][0])
        opz1.append(cz[c][0])
        opx2.append(cx[c][1])
        opy2.append(cy[c][1])
        opz2.append(cz[c][1])
        opx3.append(cx[c][2])
        opy3.append(cy[c][2])
        opz3.append(cz[c][2])
    else:
        obsx.append(obsx[c-1]+(((cx[c][0]-cx[c-1][0])+(cx[c][2]-cx[c-1][2]))/2))
        obsy.append(obsy[c-1]+(((cy[c][0]-cy[c-1][0])+(cy[c][2]-cy[c-1][2]))/2))
        obsz.append(obsz[c-1]+(((cz[c][0]-cz[c-1][0])+(cz[c][2]-cz[c-1][2]))/2))
        opx1.append(cx[c][0])
        opy1.append(cy[c][0])
        opz1.append(cz[c][0])
        opx2.append(cx[c][1])
        opy2.append(cy[c][1])
        opz2.append(cz[c][1])
        opx3.append(cx[c][2])
        opy3.append(cy[c][2])
        opz3.append(cz[c][2])
    c += 1

motionVector, distanceTraveled = [], 0.0
for c in range(len(obsx)-1):
    vector = np.sqrt((obsx[c+1]-obsx[c])**2+(obsy[c+1]-obsy[c])**2+(obsz[c+1]-obsz[c])**2)    
    motionVector.append(vector)
    distanceTraveled += vector
    
#Kalman Filter
kf = KalmanFilter(transition_matrices=np.array([[1, 1,1], [0, 1,1],[0,0,1]]),
                  transition_covariance=0.01 * np.eye(3))
predictedX = kf.em(obsx, n_iter=5).smooth(obsx)[0]
kf2 = KalmanFilter(transition_matrices=np.array([[1, 1,1], [0, 1,1],[0,0,1]]),
                  transition_covariance=0.01 * np.eye(3))
predictedZ = kf.em(obsz, n_iter=5).smooth(obsz)[0]

#Plotting
pl.figure(figsize=(15, 15))
combined_filtered = pl.plot(predictedX[:,0], predictedZ[:,0], marker='x', color='b', label='Filtered LM + RM')
pair1 = pl.plot(opx1, opz1, marker = 'o', color='r', label='Left and Mid')
pair2 = pl.plot(opx2, opz2, marker = 'o', color='g', label='Left and Right')
pair3 = pl.plot(opx3, opz3, marker = 'o', color='y', label='Mid and Right')
pl.xlim(xmin=predictedX[:,0].min()-2, xmax=predictedX[:,0].max()+2)
pl.ylim(ymin=predictedZ[:,0].min()-2, ymax=predictedZ[:,0].max()+2)
pl.legend(loc='lower right')
pl.xlabel('X position')
pl.ylabel('Z position')
pl.show()

#3D point cloud
c = 0
xyz = []
for i in obsx:
    temp = [obsx[c],obsy[c],obsz[c]]
    xyz.append(temp)
    c += 1
xyz = np.float64(xyz)
vtkControl = VTKVisualizerControl()
vtkControl.AddPointCloudActor(xyz)
vtkControl.Render()
vtkControl.ResetCamera()
plotxyz(xyz)

loopError = np.sqrt((obsx[len(obsx)-1]-obsx[0])**2+(obsy[len(obsy)-1]-obsy[0])**2+(obsz[len(obsz)-1]-obsz[0])**2)
percentageError = (loopError / distanceTraveled) * 100
print "Estimated distance traveled: " + str(distanceTraveled)
print "Loop closure error for filter: " + str(loopError) + " (" + str(percentageError) + "%)"
